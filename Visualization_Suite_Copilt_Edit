"""
VCF Visualization Suite (refactored module)

This file is an updated, more robust, and better-documented version of the original
Visualization_Suite.ipynb contained in the repository.

Key improvements:
- Input validation and helpful error messages
- Consistent angular units (radians internally; convert to degrees for display)
- Safe handling of small/invalid inputs (NaNs, short series)
- Coherence and spectrogram functions accept sampling rate (fs) and nperseg options
- DMD plotting uses consistent mode counts and alignment for reconstruction plots
- Wavelet and Granger functionality guarded behind optional imports and fallbacks
- Each visualization call in the master report is wrapped in try/except to avoid stopping
  the entire report if a single plot fails
- Logging added instead of prints for better integration into applications

Example usage (in a script or notebook):
    from vcf_visualizations import create_full_vcf_report, VisualConfig
    config = VisualConfig(fs=12.0)
    create_full_vcf_report(panel_df=panel, vector_results=vector_results,
                           harmonic_results=harmonic_results, dmd_results=dmd_results,
                           regimes=regimes, col_a='CPI', col_b='Yield_10Y', cfg=config)

Author: Copied & improved from original notebook by rudder-research
"""

from dataclasses import dataclass
import logging
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.gridspec import GridSpec
from scipy.signal import hilbert, spectrogram
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401
import warnings

# Optional libraries
try:
    import pywt
    _has_pywt = True
except Exception:
    _has_pywt = False

try:
    import statsmodels.tsa.stattools as sm_ts
    _has_statsmodels = True
except Exception:
    _has_statsmodels = False

warnings.filterwarnings("ignore")

# Logging
logger = logging.getLogger("vcf_visualizations")
if not logger.handlers:
    handler = logging.StreamHandler()
    formatter = logging.Formatter("[%(levelname)s] %(message)s")
    handler.setFormatter(formatter)
    logger.addHandler(handler)
logger.setLevel(logging.INFO)

# Plot style defaults
plt.style.use("seaborn-v0_8-darkgrid")
sns.set_palette("husl")


@dataclass
class VisualConfig:
    fs: float = 1.0  # sampling frequency (observations per time unit)
    nperseg: int = None  # default for spectrogram/coherence; None -> computed
    cmap_phase: str = "plasma"
    cmap_coherence: str = "RdYlGn"
    coherence_threshold: float = 0.5
    granger_threshold: float = 0.3
    figsize_default: tuple = (14, 8)


def _safe_nperseg(length: int, prefer: int = None):
    if prefer is not None:
        return min(prefer, max(8, length // 2))
    return min(256, max(8, length // 4))


# =======================================================================
# PART 1: VECTOR VARIANCE VISUALIZATIONS
# =======================================================================
class VectorVisualizations:
    """Visualize vector dynamics in macro-financial space."""

    @staticmethod
    def plot_vector_trajectory_3d(panel_df: pd.DataFrame, cols: list = None, cfg: VisualConfig = VisualConfig()):
        """3D trajectory of the system in phase space. Colors by time."""
        if panel_df is None or len(panel_df) == 0:
            raise ValueError("panel_df is empty or None")

        if cols is None:
            if panel_df.shape[1] >= 3:
                cols = list(panel_df.columns[:3])
            else:
                cols = list(panel_df.columns)
        if len(cols) < 2:
            raise ValueError("Need at least two columns for trajectory plotting")

        x = panel_df[cols[0]].values
        y = panel_df[cols[1]].values
        z = panel_df[cols[2]].values if len(cols) >= 3 else np.zeros_like(x)
        colors = np.arange(len(x))

        fig = plt.figure(figsize=(16, 10))
        ax = fig.add_subplot(111, projection="3d")
        scatter = ax.scatter(x, y, z, c=colors, cmap="viridis", s=20, alpha=0.6)
        ax.plot(x, y, z, color="gray", alpha=0.3, linewidth=0.5)

        # Start/end markers (defensive: length >=1)
        if len(x) > 0:
            ax.scatter([x[0]], [y[0]], [z[0]], c="green", s=200, marker="o",
                       edgecolors="black", linewidths=2, label="Start")
            ax.scatter([x[-1]], [y[-1]], [z[-1]], c="red", s=200, marker="X",
                       edgecolors="black", linewidths=2, label="End")

        ax.set_xlabel(cols[0], fontsize=12, fontweight="bold")
        ax.set_ylabel(cols[1], fontsize=12, fontweight="bold")
        ax.set_zlabel(cols[2] if len(cols) >= 3 else "Z", fontsize=12, fontweight="bold")
        ax.set_title("Vector Trajectory in Phase Space", fontsize=16, fontweight="bold", pad=20)

        cbar = plt.colorbar(scatter, ax=ax, pad=0.1)
        cbar.set_label("Time", fontsize=11)

        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()

    @staticmethod
    def plot_magnitude_evolution(vector_variance_results: dict, panel_df: pd.DataFrame, cfg: VisualConfig = VisualConfig()):
        """Show how vector magnitude changes over time. Expects vector_variance_results to contain magnitude_variance with mean and std keys (optional)."""
        if panel_df is None or len(panel_df) == 0:
            raise ValueError("panel_df is empty or None")
        if "magnitude_variance" not in (vector_variance_results or {}):
            logger.warning("vector_variance_results missing 'magnitude_variance'; proceeding with computed stats")

        vectors = panel_df.values
        magnitudes = np.linalg.norm(np.nan_to_num(vectors), axis=1)

        mean_mag = np.nan
        std_mag = np.nan
        mv = (vector_variance_results or {}).get("magnitude_variance", {})
        mean_mag = mv.get("mean_magnitude", np.nanmean(magnitudes))
        std_mag = mv.get("std_magnitude", np.nanstd(magnitudes))

        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(cfg.figsize_default[0], cfg.figsize_default[1]))
        ax1.plot(panel_df.index, magnitudes, linewidth=2, color="steelblue")
        ax1.axhline(mean_mag, color="red", linestyle="--", linewidth=2, label=f"Mean: {mean_mag:.2f}")
        ax1.fill_between(panel_df.index, mean_mag - std_mag, mean_mag + std_mag,
                         alpha=0.2, color="red", label=f"±1 STD: {std_mag:.2f}")
        ax1.set_ylabel("Vector Magnitude", fontsize=12, fontweight="bold")
        ax1.set_title("System Magnitude Over Time", fontsize=14, fontweight="bold")
        ax1.legend(fontsize=10)
        ax1.grid(True, alpha=0.3)

        ax2.hist(magnitudes, bins=50, color="steelblue", alpha=0.7, edgecolor="black")
        ax2.axvline(mean_mag, color="red", linestyle="--", linewidth=2, label="Mean")
        ax2.axvline(mean_mag - std_mag, color="orange", linestyle=":", linewidth=2, label="-1 STD")
        ax2.axvline(mean_mag + std_mag, color="orange", linestyle=":", linewidth=2, label="+1 STD")
        ax2.set_xlabel("Magnitude", fontsize=12, fontweight="bold")
        ax2.set_ylabel("Frequency", fontsize=12, fontweight="bold")
        ax2.set_title("Distribution of System Magnitude", fontsize=14, fontweight="bold")
        ax2.legend(fontsize=10)
        ax2.grid(True, alpha=0.3, axis="y")
        plt.tight_layout()
        plt.show()

    @staticmethod
    def plot_angular_dynamics(vector_variance_results: dict, panel_df: pd.DataFrame, cfg: VisualConfig = VisualConfig()):
        """
        Visualize rotational dynamics.
        Angles are computed in radians internally and converted for display to degrees.
        vector_variance_results['directional_variance']['total_rotation'] is assumed to be in radians.
        """
        if panel_df is None or len(panel_df) < 2:
            raise ValueError("Need at least two rows in panel_df to compute angular dynamics")

        vectors = panel_df.values
        angles_rad = []
        for i in range(len(vectors) - 1):
            v1 = vectors[i] / (np.linalg.norm(vectors[i]) + 1e-10)
            v2 = vectors[i + 1] / (np.linalg.norm(vectors[i + 1]) + 1e-10)
            cos_angle = np.clip(np.dot(v1, v2), -1.0, 1.0)
            angles_rad.append(np.arccos(cos_angle))

        angles_deg = np.degrees(angles_rad)

        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(cfg.figsize_default[0], cfg.figsize_default[1]))
        ax1.plot(panel_df.index[1:], angles_deg, linewidth=1.5, color="darkgreen", alpha=0.7)
        mean_angle_deg = np.nanmean(angles_deg)
        ax1.axhline(mean_angle_deg, color="red", linestyle="--", linewidth=2, label=f"Mean: {mean_angle_deg:.2f}°")
        ax1.set_ylabel("Angular Change (degrees)", fontsize=12, fontweight="bold")
        ax1.set_title("Rotational Velocity", fontsize=14, fontweight="bold")
        ax1.legend(fontsize=10)
        ax1.grid(True, alpha=0.3)

        cumulative_rotation = np.cumsum(angles_deg)
        ax2.plot(panel_df.index[1:], cumulative_rotation, linewidth=2, color="purple")
        total_rot_rad = (vector_variance_results or {}).get("directional_variance", {}).get("total_rotation", np.sum(angles_rad))
        total_rot_deg = np.degrees(total_rot_rad)
        ax2.set_ylabel("Cumulative Rotation (degrees)", fontsize=12, fontweight="bold")
        ax2.set_title(f"Total System Rotation: {total_rot_deg:.1f}°", fontsize=14, fontweight="bold")
        ax2.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

    @staticmethod
    def plot_divergence_curl(vector_variance_results: dict, cfg: VisualConfig = VisualConfig()):
        """Plot divergence time series if present."""
        divergence = (vector_variance_results or {}).get("divergence", None)
        if divergence is None:
            raise ValueError("vector_variance_results does not contain 'divergence' Series")

        if isinstance(divergence, (pd.Series, pd.DataFrame)):
            if isinstance(divergence, pd.DataFrame):
                # If it's a df, try to pick first column
                divergence = divergence.iloc[:, 0]
        else:
            # Try to coerce
            divergence = pd.Series(divergence)

        fig, ax = plt.subplots(1, 1, figsize=(cfg.figsize_default[0], cfg.figsize_default[1] // 1.5))
        ax.plot(divergence.index, divergence.values, linewidth=2, color="crimson", label="Divergence")
        ax.axhline(0, color="black", linestyle="-", linewidth=1, alpha=0.5)
        ax.fill_between(divergence.index,
